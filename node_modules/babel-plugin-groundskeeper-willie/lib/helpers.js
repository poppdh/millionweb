/**
 * @fileoverview This file contains helper methods for dealing with the AST,
 * finding pragmas, etc.
 */
'use strict';

/**
 * Check if a comment is a line-disabling comment.
 * @param  {Object} comment       Comment AST object.
 * @param  {Regex} disabledRegex  The Regex to determine what is a disable-line-directive.
 * @return {Boolean}              If the comment is intended to disable its line.
 */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var isLineDisableComment = function isLineDisableComment(comment, disabledRegex) {
    return (comment.type === 'CommentLine' || comment.type === 'CommentBlock' && comment.loc.start.line === comment.loc.end.line) && comment.value.match(disabledRegex);
};

/**
 * Fetch all lines that have Groundskeeper Willie disable-line directives.
 * @param  {Array} comments       The AST comment array for a file.
 * @param  {Regex} disabledRegex  The Regex to determine what is a disable-line-directive.
 * @return {Array}                Array of source lines that are disabled.
 */
var fetchDisabledLines = function fetchDisabledLines(comments, disabledRegex) {
    return comments.filter(function (comment) {
        return isLineDisableComment(comment, disabledRegex);
    }).map(function (comment) {
        return comment.loc.start.line;
    });
};

/**
 * Fetches all comment pragmas from a given set of file comments. This is the
 * primary way we decide what is in and what is outside of a groundskeeper pragma.
 * If a pragma is closed without being opened, or, at the end of the parsing run
 * has not been closed by a matching closing tag, this method will throw.
 * @param  {Array[Object]} comments  Array of comment AST objects.
 * @param  {Regex} pragmaRegex       The Regex to match a line disable directive.
 * @return {Array[Object]}           Array of pragma definitions.
 */
var fetchPragmas = function fetchPragmas(comments, pragmaRegex) {
    var completePragmas = [];
    var openPragmas = [];
    comments.forEach(function (comment) {
        var pragmaPieces = pragmaRegex.exec(comment.value);

        if (pragmaPieces) {
            // If it's a pragma
            var _pragmaPieces = _slicedToArray(pragmaPieces, 3);

            var bookendToken = _pragmaPieces[1];
            var pragmaName = _pragmaPieces[2];

            if (bookendToken === '') {
                // If it's an open:
                // Push on to the open pragma's list with a name and a loc.
                openPragmas.push({ name: pragmaName, loc: { start: comment.loc.start } });
            } else {
                // If it's a close:
                var found = false;
                // Run from the back of the list with the name. When found remove from list and push to pragmaOutput
                for (var i = openPragmas.length - 1; i >= 0; i--) {
                    if (openPragmas[i].name === pragmaName) {
                        found = true;
                        openPragmas[i].loc.end = comment.loc.end;
                        completePragmas.push(openPragmas[i]);
                        openPragmas.splice(i, 1);
                        break;
                    }
                }
                if (!found) {
                    // If you get to the end without closing the pragma, throw an error.
                    throw new Error('Error in Groundskeeper Willie: </' + pragmaName + '> tried to close, but is not open.');
                }
            }
            comment.ignore = true; // Remove the pragma comment
        }
    });
    // If there are any left open, throw an error.
    if (openPragmas.length) {
        throw new Error('Error in Groundskeeper Willie: Pragma(s) left unclosed ' + JSON.stringify(openPragmas, null, 4));
    }
    return completePragmas.map(function (pragma) {
        return pragma.loc;
    });
};

/**
 * Check if a node fall within any of the defined pragmas.
 * @param  {Object} node    The AST node being checked.
 * @param  {Array} pragmas  The array of active pragmas to check over.
 * @return {Boolean}        If the node falls within any of the pragmas.
 */
var isInsidePragma = function isInsidePragma(node, pragmas) {
    for (var i = 0; i < pragmas.length; i++) {
        var pragma = pragmas[i];
        var nodeLoc = node.loc;
        if (nodeLoc && nodeLoc.end && nodeLoc.start) {
            var insideStart = nodeLoc.start.line > pragma.start.line || nodeLoc.start.line === pragma.start.line && nodeLoc.start.column > pragma.start.column;

            var insideEnd = nodeLoc.end.line < pragma.end.line || nodeLoc.end.line === pragma.end.line && nodeLoc.end.column < pragma.end.column;
            if (insideStart && insideEnd) {
                return true;
            }
        }
    }
    return false;
};

/**
 * Determine if a node starts on a line where Groundskeeper Willie should be
 * disabled.
 * @param  {Array} (disabledLines)  An array of disabled source lines
 * @param  {Object} (path)          The AST path object for the node to check.
 * @return {Boolean}                If the node provided falls within any of the
 *                                  disabled lines provided. Returns false if
 *                                  path or disabled lines are not given.
 */
var isOnDisabledLine = function isOnDisabledLine() {
    var disabledLines = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
    var path = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (path.node && path.node.loc && path.node.loc.start) {
        return disabledLines.indexOf(path.node.loc.start.line) !== -1;
    }
    return false;
};

module.exports = {
    fetchDisabledLines: fetchDisabledLines,
    fetchPragmas: fetchPragmas,
    isInsidePragma: isInsidePragma,
    isLineDisableComment: isLineDisableComment,
    isOnDisabledLine: isOnDisabledLine
};